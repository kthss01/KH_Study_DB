--DDL(CREATE TABLE ) 및 제약조건

--DDL(DATA DEFINITION LANGUAGE) : 데이터 정의  언어
--객체(OBJECT) 를 만들고 (CREATE) , 수정(ALTER) 하고 삭제(DROP)하는 구문

--오라클에서의 객체 
--테이블 (TABLE), 뷰(VIEW), 시퀀스(SEQUENCE) , 인덱스(INDEX)
--패키지 (PACKAGE), 트리거(TRIGGER), 동의어(SYNONYM),
--프로시져(PROCEDURE), 함수(FUNCTION), 사용자 (USER)

--테이블 만들기 
--[표현식] :
--CREATE TABLE 테이블명(컬럼명 자료형(크기) , 컬럼명 자료형(크기)....);

CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
    
);


SELECT * FROM MEMBER;

-- 컬럼에 주석 달기
-- [표현식]
-- COMMENT ON COLRUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';


-- 테이블의 정보
SELECT *
FROM SYS.USER_TABLES;


-- 테이블내 컬럼 정보
SELECT 
    *
FROM SYS.USER_TAB_COLUMNS
WHERE TABLE_NAME = 'MEMBER';

--제약조건 
-- 테이블작성시 각 컬럼에 대해 값 기록에 대한 제약조건을 설정할수 있다. 
-- 데이터 무결성 보장을 목적으로함 
-- 입력 / 수정 하는 데이터에 문제가 없는지 자동으로 검사하는 목적
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY


-- 제약조건정보확인
--테이블의 제약조건 검색
SELECT * 
FROM SYS.USER_CONSTRAINTS;

-- 컬럼의 제약조건 검색
SELECT *
FROM SYS.USER_CONS_COLUMNS;

-- NOT NULL: 해당 컬럼에 반드시 값을 기록 해야하는 경우 사용
--           삽입/수정시 NULL 값을 허용하지 않도록 '컬럼 레벨'에서 제한


CREATE TABLE USER_NOCONS (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

SELECT * FROM USER_NOCONS;

INSERT INTO USER_NOCONS
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_NOCONS
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (2, NULL, NULL, NULL, NULL, '010-1234-5678', 'yu@kh.or.kr');
    

CREATE TABLE USER_NOTNULL (
    USER_NO NUMBER NOT NULL, -- 컬럼 레벨에서 제약조건 설정
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UC.TABLE_NAME = 'USER_NOTNULL';
-- CONSTRAINT_TYPE 이 'C'인 일종의 CHECK 제약조건 이다

INSERT INTO USER_NOTNULL
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', NULL, NULL, '010-1234-5678', 'yu@kh.or.kr');


-- UNIQUE 제약조건 : 컬럼에 입력값에 대한 중복을 제한하는 제약조건
--                  컬럼 레벨에서 설정 가능, 테이블 레벨에서도 설정 가능

SELECT * FROM USER_NOCONS;

INSERT INTO USER_NOCONS
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
    
CREATE TABLE USER_UNIQUE (
    USER_NO NUMBER,
--    USER_ID VARCHAR2(20) UNIQUE NOT NULL, -- 컬럼레벨에서 제약조건 설정, NOT NUㅣLL도 같이 간으
    USER_ID VARCHAR2(20) UNIQUE, -- 컬럼레벨에서 제약조건 설정
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_UNIQUE
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_UNIQUE
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');

SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UCC.CONSTRAINT_NAME = 'SYS_C007088'; -- 선생님과 에러 이름이 다를 수 있음
-- CONSTRAINT_TYPE : 'U'

DROP TABLE USER_UNIQUE2;

CREATE TABLE USER_UNIQUE2 (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_ID) -- 테이블 레벨에서 제약조건 설정
);

INSERT INTO USER_UNIQUE2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_UNIQUE2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, NULL, 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
SELECT * FROM USER_UNIQUE2;

-- NOT NULL은 컬럼 레벨에서만 쓸 수 있음

-- 두 개의 컬럼을 묶어서 하나의 UNIQUE 제약조건 설정
-- 컬럼 레벨이 아닌 테이블 레벨에서 설정
CREATE TABLE USER_UNIQUE3 (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_NO, USER_ID) -- 테이블 레벨에서 제약조건 설정
);

INSERT INTO USER_UNIQUE3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE3 -- ORA-00001: unique constraint (EMPLOYEE.SYS_C007095) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user02', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
INSERT INTO USER_UNIQUE3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (2, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
SELECT * FROM USER_UNIQUE3;

-- 제약조건명 부여, 지정해주지 않으면 시스템에서 알아서 임의의 제약조건명 부여
-- 제약조건명을 회사의 네이밍 룰에 따르고, 어떤 제약조건이 위배되는지 한눈에 파악 가능

CREATE TABLE CONS_NAME (
    TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL, -- NN NOT NULL
    TEST_DATA2 VARCHAR2(20) CONSTRAINT UK_TEST_DATA2 UNIQUE, -- UK UNIQUE 
    TEST_DATA3 VARCHAR2(30),
    CONSTRAINT UK_TEST_DATA3 UNIQUE(TEST_DATA3)
);

SELECT *
FROM SYS.USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';


-- CHECK 제약조건 : 컬럼에 기록되는 값에 조건을 설정할 수 있음
-- CHECK(컬럼명 비교연산자 비교값)
-- 주의 : 비교값은 리터럴만 사용할 수 있음, 변하는 값이나 함수는 사용 못함. (자동 NOT NULL 규칙 적용됨)

CREATE TABLE USER_CHECK(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_CHECK
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
INSERT INTO USER_CHECK -- ORA-02290: check constraint (EMPLOYEE.SYS_C007100) violatedORA-02290: check constraint (EMPLOYEE.SYS_C007100) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남자', '010-1234-5678', 'yu@kh.or.kr');
    
SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UCC.CONSTRAINT_NAME = 'SYS_C007100'; 


CREATE TABLE TEST_CHECK (
    TEST_NUMBER NUMBER,
    CONSTRAINT CK_TEST_NUMBER CHECK(TEST_NUMBER > 0)
);

INSERT INTO TEST_CHECK 
    (TEST_NUMBER)
    VALUES 
    (10);
    
INSERT INTO TEST_CHECK -- ORA-02290: check constraint (EMPLOYEE.CK_TEST_NUMBER) violated
    (TEST_NUMBER)
    VALUES 
    (-10);
    
    
CREATE TABLE TBL_CHECK (
    C_NAME VARCHAR2(10),
    C_PRICE NUMBER,
    C_LEVEL CHAR(1),
    C_DATE DATE,
    CONSTRAINT CK_C_PRICE CHECK(C_PRICE >= 1 AND C_PRICE <= 9999),
    CONSTRAINT CK_C_LEVEL CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    CONSTRAINT CK_C_DATE CHECK(C_DATE >= TO_DATE('2016/01/01', 'YYYY/MM/DD'))
);

-- 회원 가입용 테이블 생성(USER_TEST)
-- 컬럼명 : USER_NO(회원번호)
--         USER_ID(회원아이디) -- 중복 금지, NULL값 허용 안함
--         USER_PWD(회원비밀번호) -- NULL값 허용 안함
--         PNO(주민등록번호) -- 중복금지, NULL값 허용 안함
--         GENDER(성별) -- '남' 혹은 '여'로 입력
--         PHONE(연락처)
--         ADDRESS(주소)
--         STATUS(탈퇴여부) -- NOT NULL, 'Y' 혹은 'N'으로 입력
-- 각 컬럼에 제약조건 이름 부여
-- 각 컬럼별로 코멘트 생성
-- 5명 이상 회원 정보 INSERT

SELECT * FROM USER_TEST;

DROP TABLE USER_TEST;

SELECT *
FROM SYS.USER_CONSTRAINTS;

SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;

CREATE TABLE USER_TEST (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) CONSTRAINT NN_USER_ID NOT NULL, -- NOT NULL은 컬럼 레벨에서만 가능해서 제약조건 이름 부여도 컬럼 레벨에서만
    USER_PWD VARCHAR2(20) CONSTRAINT NN_USER_PWD NOT NULL,
    PNO VARCHAR2(20) CONSTRAINT NN_PNO NOT NULL,
    GENDER VARCHAR(3),
    PHONE VARCHAR2(20),
    ADDRESS VARCHAR2(100),
    STATUS VARCHAR(3) CONSTRAINT NN_STATUS NOT NULL,
    CONSTRAINT UK_USER_ID UNIQUE(USER_ID),
    CONSTRAINT UK_PNO UNIQUE(PNO),
    CONSTRAINT CK_GENDER CHECK(GENDER IN ('남', '여')),
    CONSTRAINT CK_STATUS CHECK(STATUS IN ('Y', 'N')) -- 테이블 삭제하면 이런 제약조건도 같이 날라감
);

COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민등록번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '연락처';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';

INSERT INTO USER_TEST
--    (USER_NO, USER_ID, USER_PWD, PNO, GENDER, PHONE, ADDRESS, STATUS) -- 다 쓸거면 안써도됨
    VALUES
    (1, 'user01', 'pass01', '881211-1234567', '남', '010-1234-5678', '서울시 강남구 역삼동', 'N');
INSERT INTO USER_TEST
    VALUES
    (2, 'user02', 'pass02', '881212-1234567', '남', '010-1234-5678', '서울시 강남구 역삼동', 'N');
INSERT INTO USER_TEST
    VALUES
    (3, 'user03', 'pass03', '881213-1234567', '남', '010-1234-5678', '서울시 강남구 역삼동', 'N');
INSERT INTO USER_TEST
    VALUES
    (4, 'user04', 'pass04', '881214-1234567', '남', '010-1234-5678', '서울시 강남구 역삼동', 'N');
INSERT INTO USER_TEST
    VALUES
    (5, 'user05', 'pass05', '881215-1234567', '남', '010-1234-5678', '서울시 강남구 역삼동', 'N');
    
    
--PRIMARY KEY(기본키) 제약조건 
-- : 테이블에서 한행의 정보를 찾기위해 사용할 컬럼을 의미
-- 테이블에 대한 식별자 역할을 한다. 
-- NOT NULL+ UNIQUE제약조건의 의미
-- 한 테이블당 한개만 설정
-- 컬럼 레벨, 테이블 레벨 둘다 설정 가능함
-- 한개 컬럼에 설정할수 있고, 여러개 컬럼 묶어서(복합키) 설정 할수 있음 

CREATE TABLE USER_PRIMARYKEY (
    USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY, -- 컬럼 레벨에서 지정
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_PRIMARYKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_PRIMARYKEY -- ORA-00001: unique constraint (EMPLOYEE.PK_USER_NO) violated
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user02', 'pass02', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_PRIMARYKEY -- ORA-01400: cannot insert NULL into ("EMPLOYEE"."USER_PRIMARYKEY"."USER_NO")
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (NULL, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');

SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UCC.CONSTRAINT_NAME = 'PK_USER_NO'; 
-- CONSTRAINT_TYPE : P 

DROP TABLE USER_PRIMARYKEY2;

CREATE TABLE USER_PRIMARYKEY2 (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID) -- 테이블 레벨에서 지정, 둘다 같아야 함
);

INSERT INTO USER_PRIMARYKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_PRIMARYKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (1, 'user02', 'pass02', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
INSERT INTO USER_PRIMARYKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL)
    VALUES
    (2, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr');
    
SELECT * FROM USER_PRIMARYKEY2;

DESC USER_PRIMARYKEY2;

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'MEMBER';


-- FOREIGN KEY(외부키 / 외래키) 제약조건 : 
-- 참조(REFERENCES)된 다른 테이블에서 제공하는 값만 사용할 수 있음
-- 참조 무결성을 위배하지 않게 하기 위해 사용
-- FOREIGN KEY제약조건에 의해서 
-- 테이블간의 관계(RELATIONSHIP)가 형성됨--> JOIN이 가능해짐 
-- 제공되는 값 외에는 NULL을 사용할 수 있음

-- 컬럼레벨일 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 이름] REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]

-- 테이블 레벨일 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할컬럼명) REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]


-- 참조할 테이블의 참조할 컬럼명이 생략되면
-- PRIMARY KEY로 설정된 컬럼이 자동 참조할 컬럼이 됨
-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과,
-- UNIQUE 지정된 컬럼만 외래키로 사용할 수 있음

CREATE TABLE USER_GRADE (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE
    VALUES(10, '일반회원');

INSERT INTO USER_GRADE
    VALUES(20, '우수회원');

INSERT INTO USER_GRADE
    VALUES(30, '특별회원');
    
SELECT * FROM USER_GRADE;


CREATE TABLE USER_FOREIGNKEY (
    USER_NO NUMBER PRIMARY KEY, -- 컬럼 레벨에서 지정
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
    -- USER GRADE 테이블에 있는 GRADE_CODE를 참조하겠다.
);

INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (2, 'user02', 'pass02', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);
    
INSERT INTO USER_FOREIGNKEY
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (3, 'user03', 'pass03', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', NULL);

INSERT INTO USER_FOREIGNKEY -- ORA-02291: integrity constraint (EMPLOYEE.FK_GRADE_CODE) violated - parent key not found
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (4, 'user04', 'pass04', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 50);

INSERT INTO USER_FOREIGNKEY 
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (5, 'user05', 'pass05', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 30);

SELECT * FROM USER_FOREIGNKEY;

SELECT 
    UC.*, UCC.*
FROM SYS.USER_CONSTRAINTS UC
JOIN SYS.USER_CONS_COLUMNS UCC ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UCC.CONSTRAINT_NAME = 'FK_GRADE_CODE'; 
-- CONSTRAINT_TYPE : R

-- USER_FOREIGNKEY 테이블에서
-- 회원아이디, 이름, 성별, 연락처, 회원등급명을 조회하시오
SELECT
    A.USER_ID
    , A.USER_NAME
    , A.GENDER
    , A.PHONE
    , B.GRADE_NAME
FROM USER_FOREIGNKEY A
--LEFT JOIN USER_GRADE B ON A.GRADE_CODE = B.GRADE_CODE;
NATURAL LEFT JOIN USER_GRADE B; -- 잘 쓰이지는 않은데 NATURAL JOIN 하면 동일한 이름의 컬럼을 찾아준다고 함


-- 삭제 옵션
--: 부모테이블의 데이터 삭제시 자식 테이블의 데이터를 어떤식으로 처리할지에 대한 내용 설정

DELETE FROM USER_GRADE WHERE GRADE_CODE = 10; -- ORA-02292: integrity constraint (EMPLOYEE.FK_GRADE_CODE) violated - child record found
-- ON DLEETE RESTRICTED 기본적으로 지정되어있음.
-- FOREIGN KEY 로 지정된 컬럼에서 사용되고 있는 값일 경우, 제공하는 컬럼의 값은 삭제 할 수 없음.

DELETE FROM USER_GRADE WHERE GRADE_CODE = 20; -- 안쓰고 있기 때문에 20은 지울 수 있음

SELECT * FROM USER_GRADE;

-- ON DELETE SET NULL: 부모키 삭ㅈ제시 자식키를 NULL로 변경하는 옵션
CREATE TABLE USER_GRADE2 (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE2
    VALUES(10, '일반회원');

INSERT INTO USER_GRADE2
    VALUES(20, '우수회원');

INSERT INTO USER_GRADE2
    VALUES(30, '특별회원');
    
SELECT * FROM USER_GRADE2;


CREATE TABLE USER_FOREIGNKEY2 (
    USER_NO NUMBER PRIMARY KEY, -- 컬럼 레벨에서 지정
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE2(GRADE_CODE) ON DELETE SET NULL
    -- USER GRADE 테이블에 있는 GRADE_CODE를 참조하겠다.
);

INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (2, 'user02', 'pass02', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);
    
INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (3, 'user03', 'pass03', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', NULL);
    
INSERT INTO USER_FOREIGNKEY2
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (4, 'user04', 'pass04', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 30);

SELECT * FROM USER_GRADE2;
SELECT * FROM USER_FOREIGNKEY2;
DELETE FROM USER_GRADE2 WHERE GRADE_CODE = 10; -- 참조 중인 거 다 NULL로 바꿈


-- ON DELETE CASCADE: 부모키 삭제 시 자식키를 가진 행도 삭제

CREATE TABLE USER_GRADE3 (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE3
    VALUES(10, '일반회원');

INSERT INTO USER_GRADE3
    VALUES(20, '우수회원');

INSERT INTO USER_GRADE3
    VALUES(30, '특별회원');
    
SELECT * FROM USER_GRADE3;


CREATE TABLE USER_FOREIGNKEY3 (
    USER_NO NUMBER PRIMARY KEY, -- 컬럼 레벨에서 지정
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE3(GRADE_CODE) ON DELETE CASCADE
    -- USER GRADE 테이블에 있는 GRADE_CODE를 참조하겠다.
);

INSERT INTO USER_FOREIGNKEY3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (1, 'user01', 'pass01', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (2, 'user02', 'pass02', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 10);
    
INSERT INTO USER_FOREIGNKEY3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (3, 'user03', 'pass03', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', NULL);
    
INSERT INTO USER_FOREIGNKEY3
    (USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL, GRADE_CODE)
    VALUES
    (4, 'user04', 'pass04', '유재석', '남', '010-1234-5678', 'yu@kh.or.kr', 30);

SELECT * FROM USER_GRADE3;
SELECT * FROM USER_FOREIGNKEY3;
DELETE FROM USER_GRADE3 WHERE GRADE_CODE = 10; -- 참조 중인 것도 같이 삭제


-- 서브쿼리를 이용한 테이블 생성 (컬럼명, 데이터 타입, 값이 복사되고, 제약조건은 NOT NULL만 복사됨)

CREATE TABLE EMPLOYEE_COPY 
AS SELECT * FROM EMPLOYEE; -- NOT NULL만 복사됨, 데이터도 조회한건 다 들어와있음, COMMENT 없음

DROP TABLE EMPLOYEE_COPY;

-- 구조만 복사할 때, COMMENT도 없음
CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE WHERE 1=0; -- WHERE 1=0 하면 구조만 복사됨 조건이 FALSE라 안나옴

CREATE TABLE EMPLOYEE_COPY2
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
LEFT JOIN JOB USING(JOB_CODE);


--제약조건 추가 
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명 (컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명 비교연산자 비교값)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY(EMP_ID);
--ALTER TABLE EMPLOYEE_COPY MODIFY EMP_NAME NULL; -- 하면 제약조건에서 사라짐
ALTER TABLE EMPLOYEE_COPY MODIFY EMP_NAME NOT NULL; -- 하면 제약조건에 추가됨


